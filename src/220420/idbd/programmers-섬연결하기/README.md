## 문제 링크

---

## 소요 시간 및 테스트 시도 횟수

| 소요시간(m) | 테스트 시도 횟수 |
| ----------- | ---------------- |
| 360         | 00               |

---

## 생각의 흐름

> 조건 1. 모든 섬이 연결되어야 한다.

- 모든섬이 연결되어 있다는 것은 어떻게 알까

  - 비용을 선택할때마다 선택된 섬의 인덱스를 저장
  - 모든 섬의 인덱스가 다 저장되면 섬이 모두 연결 된 것으로 보자 (x 아니었음)
  - 만약 [0, 1, 1], [2, 3, 1] => 인경우에는 모든 섬의 인덱스가 선택되겠지만 0과 1만 연결 2와 3만 연결 되어 서로 4섬 자체가 연결되지 않는다.

  ```
  n = 4 일때
  {
    0: 0,
    1: 0,
    2: 0,
    3: 0,
    [섬의 인덱스]: 선택받을 때마다 카운트
  }
  ```

  위의 자료구조에서 모든 키값이 1 이상 이어야 하고, 키값의 합이 n + 2 이상면 모두다 연결된 것으로 봄.
  그런데 n + 2가 결국에는 최소 값이 되겠지

> 조건 2. 최소비용

- 최소비용은 Math.min으로 리턴된 값을 다음 연산의 비용과 비교하면 됨

> 조건 3. 중복이 없다.

- 그렇단다

> 생각 1. 주어진 배열을 정렬하고 시작할 필요가 있나?

- 주어진 배열을 정렬할 필요가 있겠다.
- 어떤 정렬이냐 => 비용 기준으로 오름차순으로 정렬을 함
- 후에 비용을 선택해 나가면서 조건 1을 만족시키는

## 풀이

> 조건 3, 중복이 없다가 중요한 힌트였다.

> 예를 들어 n이 4일 때
>
> |     | 0   | 1   | 2   | 3   |
> | --- | --- | --- | --- | --- |
> | 0   | x   | o   | o   | o   |
> | 1   | x   | x   | o   | o   |
> | 2   | x   | x   | x   | o   |
> | 3   | x   | x   | x   | x   |
>
> 생각
>
> - 다음 표에서 서로 같은 숫자 제외, 중복 제외 하면 o 부분만 남는다.
> - costs 라는 배열의 요소는 o에 속한다.
> - 행 또는 열을 기준으로 했을 때 각 레벨 별로 하나의 요소는 꼭 들어가야 한다. => 그래야 모든 섬이 연결되는 조건을 충족한다. (위 조건 1)
> - 각 레벨별로 최솟값을 찾아서 더해줌.
> - 그런데 중요한 점은 위의 작업을 했을 때 행을 기준으로 한 최솟값과 열을 기준으로 한 최솟값이 다르다.
> - 그래서 행을 기준으로 한것과 열을 기준으로 한 것을 비교하고 더 작은 값을 리턴
>
> 정리
>
> 1. 행을 기준으로 각 레벨별로 최솟값을 구하고 최솟값의 총합을 구한다.
> 2. 열을 기준으로 각 레벨별로 최솟값을 구하고 최솟값의 총합을 구한다.
> 3. 열과 행을 비교해서 더 작은 값을 결과값으로!

> 오류가 있음

- 각 레벨 별로 요소가 없을 수도 있음

> 예 ) 5 [[0, 1, 1], [0, 4, 5], [2, 4, 1], [2, 3, 1], [3, 4, 1]] 8
>
> |     | 0   | 1   | 2   | 3   | 4   |
> | --- | --- | --- | --- | --- | --- |
> | 0   | x   | 1   |     |     | 5   |
> | 1   | 1   | x   |     |     |     |
> | 2   |     |     | x   | 1   | 1   |
> | 3   |     |     | 1   | x   | 1   |
> | 4   | 5   |     | 1   | 1   | x   |

> ## 크루스칼 알고리즘

> 크루스칼 알고리즘은 최소비용 신장트리
>
> 예를 들어 여러개의 도시를 최소한의 비용으로 연결시킬 때 적용할 수 있는 알고리즘
>
> 특징은 n개의 도시가 있다고 했을 때, 도시를 잇는 간선의 최소한의 개수는 반드시 n-1개
>
> 사이클 테이블을 이용해서 어떤 노드들끼리 연결되었는지 확인 할 수 있다.
>
> - 사이클 테이블이란 각 인덱스의 노드가 어떠한 노드와 연결이 되었는가를 알아 볼 수 있는 테이블
> - | 노드 인덱스                     | 0   | 1   | 2   | 3   | 4   | 5   |
>   | ------------------------------- | --- | --- | --- | --- | --- | --- |
>   | 연결된 노드 중 제일 작은 인덱스 | 1   | 2   | 1   | 2   | 1   | 2   |
>
>   위과 같다면 0번, 2번, 4번 노드가 서로 연결, 1번, 3번 5번 노드가 서로 연결이 되어 있다.

## 풀이

> 1. 비용을 기준으로 오름차순 정렬을 한다.
> 2. 두섬이 연결이 아직 안되었다(사이클 테이블의 값이 다르다)면 큰 쪽을 작은 쪽으로 수정하고 큰 쪽과 값이 같은 나머지 테이블도 작은쪽으로 수정하고 비용을 총 비용에 더해준다.
> 3. 만약 이미 연결이 되었다(사이클 테이블의 값이 같다.)면 무시하고 지나간다.
> 4. 총비용 도출
